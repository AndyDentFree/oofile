goFirstRecordgoLastRecordgoNextRecordgoPreviousRecordthese callchangedSelection					METHOD changesSekection	    rtey and lock the record	    bool someoneElseLocked = false;		IF someoneElseLocked THEN			broadcast OOFmsg_ChangeSelection, kRecordLockedByOtherUser		ELSE			broadcast OOFmsg_ChangeSelection, 0		END_IF			these message go to dbAbstractEditHelper::receiveMsg and set readonly flag on the record and all asscotaied linksthis will not work in transaction model, i think. the locked will be replaced with a begin we will revolvelock conflicts at coomit time, same as lock(free).now as we walk down links we must be able to use autosave for nbow and auto rewinf=-=-=-=-=-FROM ctprog.pdf"When you invoke Begin you can OR the constants ENABLE or READREC into thetransaction mode. If you want the locks to block when they are not available, then alsoOR LK_BLOCK into the transaction mode. This will automatically invoke a Lock-ISAMcall, so that all ISAM update functions will automatically lock records. Duringthe transaction you can modify the ISAM lock mode by further calls to LockISAM.Low level functions will still require that you explicitly lock the records withLockCtData.:faircom ctfuncrf.pdf states"To call PermIIndex, you must have the underlying Incremental files opened exclu-sively."If SAVENV is ORÕed into trnmod, or if the user profile includes USERPRF_SAVENV(see InitCtreeXtd), then the current ISAM position of the files updated during thetransaction will be saved so that a subsequent Abort or RestoreSavePoint will resetthe current ISAM position of the files.Automatic Savepoints - AUTOSAVE will automatically follow each successfulISAM update or resource update with a special savepoint. The savepoint permits anupdate error to be rolled-back so that a compound transaction can continue its updatesand subsequently commit the transaction. This automatic savepoint does NOT supportthe SAVENV profile setting. SAVENV is disabled if AUTOSAVE is on.This approach is faster than explicit savepoints after each update since no networktraffic is required between updates, and the auto savepoint is more efficient than anexplicit savepoint.If an error occurs in the middle of a set of updates within a single transaction, and ifAUTOSAVE was in the TRANBEG mode, then the application simply calls Restore-SavePoint(-1) (TRANRST is short function name) to roll-back the error, and thencontinues update processing.Explicit calls to SetSavePoint() (TRANSAV is short function name) should not bemade when AUTOSAVE is effective. An ASAV_ERR (error 532) will be returned bySetSavePoint if called after updates have occurred. A typical usage pattern in pseudo-codewould be:TRANBEG(TRNLOG | AUTOSAVE | ENABLE)loop: update operationif not done goto loopTRANEND(...)"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-	try {		mTable->lockRecord();	}	catch (oofE_RecordLocked&) {		oofYNC("Someone else is editing this record - you will not be able to make any changes");		someoneElseLocked = true;	}	if (someoneElseLocked) 		(OOFmsg_ChangeSelection, kRecordLockedByOtherUser, dontNeedToTell);	else 		broadcast(OOFmsg_ChangeSelection, 0, dontNeedToTell); END_METHODin  a gui does each list box have a lockisam, if so this will cause us some grief as we want to havethe trnaction on the parent and locks on all the child tables, we can have auto locking after the trnasactionbegins but we must watch out are we allowed nested transaction acllsmaybe we need a =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-290100HOW GUI WORKS1. When the GUI go's to a record on a table the record is locked and loaded	1.1 if a record was already loaded it will be unlocked