=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-OOFServer DESIGN DECISIONS Minimal requirements we must add api stuf to enter user iD password etc to InitISAMXtdwe must add interface to set up group domains maybe? NO FROM ADMINBecause connection can be made at differmt times we should have a user object to keep track of user details	userprof	userid, 32 byte ASCIIZ string (i.e., a null terminated ASCII string).User	userword, 10 byte ASCIIZ	servname should this be in user?	userprofile desribes we could stor this in user or we could have calls to coonent with preset profiles ?the user object wil have a basic command line interface to input names and password, with hooks for other interfaces maybe	THIS IS NOW DONE=-=-=-=-=-=-=-=-=-=-=-=-=-=-=+2000/01/2in dbConnect_ctree::SetupConnection WILL USE  connectionName TO PASS IN SERVER NAMECURRENTLY CONNECTION STUFF ONLY PASSES IN CONNECTIONN, WE NEED TO PASS DOWN other details about a user so will add a user ref doen will set this 00; long by default so no effect on existing code use of this will be wrpped into ifdefs no thats dumb we could use diifernt signature initially i will jsust use defailtswe must store user profile in user although differnt connections in one application might have differnt progileseg one connection might have a local datavase and one might be on server  When using the FairCom security feature, each user that will use the Server must begiven a User ID by the System Administrator. The ID is a 32 byte ASCIIZ string (i.e.,a null terminated ASCII string).UserPasswordEach User ID can have an optional user password. The password is a 10 byte ASCIIZstring.have a new class dbconneCTServer does file existwe use #define IS_CLIENT to wrap server support specific code, eg transactionsANDY said there is a standard ctree sever deinecheck admin doc about files, pc world is word aligned mac is bytelater found out that we need the connection name to keep track of superfiles if used so instead will add the server name to user objectAndy suggested that we use the name dbUser and so we will OOFServer DESIGN DECISIONS00/01/16CLASS dbConnectMethod fileExiststhis call currently uses oofdirectiry call to find out if file existswwe need this call to allow us to connections, however as in a client server modelwe cannot use the oofdirctory call very easily. faircom supply a user code resource that appears to allow a client (user) to run code on ther server.. invesyigate it Spoke to andy said that not what user is for. maybe instead try to connect look at error and then make a file if it does not existtry (see sctree function refpg 173result = OpenCtFile(switch (result)	case FNOP_ERR:		file most probalbu does not exist so return false	case FUNK_ERR, FCRP_ERR	, FNUM_ERR, KSIZ_ERR, FVER_ERR, KLEN_ERR, FUSE_ERR		assert error in file	default closeCtFile		return trueend_switch we will close file so that existing code can open and connect	if ( OpenCtFile(invfil,filnam,(SHARED | PERMANENT)))	printf(Ò\nUnsuccessful file open.Ó);	use of this functionrequiresthat ctreebe initilised so we cannot use it before open connection as we do in other uses discusion with andy maybe be make a newinterface openOrCreate()call dbUser logINObjectother issiues we must add support for CreateIFileXtd and it's asscoiated functionsto add extra secutiry functionality -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-was going to add functionality to check that a file exist on server to static bool dbConnect::fileExists but this then requies that dbconnect has acces to ctree declarationscleaner solution is to add a method is FileOnserver to dbConnectCtreeso i will do thisnoot this no->  but make a vitual method isFileonServer so we can get at the check from dbConnect(const char * fName, dbUser *optionalLoginInfo=0 );thiswill not but had trouble as we cannot check files on server with ctreeinitisam, ie we cannot check if the files exist on the server before we are well into connectingwhere as  the existing samples rely on  -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000117FILE EXIST ON SERVER PROBLEMWhat we really need is an open with create method, which opens a file if it exists elseit cratesa nd opens the file, as an alternative we set a flag mOpenOrCreatethis means that we could use exsiting code. i think i will use a new method openOrCreate(), for now it will be in ctree onlyif we lose a file in a database this means we would create an empty table!if it a super file we are opening it does not matter, (why?) perhaps because all data is lost we will be just opening a new dtat base if it is a table we should throw an exception perhapsif we use a flag it would mean minimal changesNo flags are too global, so pass an otional paramter default = 0 	openOrCreate		set mOpenOrCreate-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000118 FILE EXIST ON SERVER PROBLEM	 final solution was to add the new method openOrCreate onofc_ctreeconnection this in in calls	 a modfified open method with an optional bool * parammeter (default = 0) set to true	 the modifie dopen method & finnish open connection will attempt to open the file, i	 f this is not possible and the error is file not found(ie not a corruption error, the file will be created else	 an exception will be thrown. Also andy suggseted that this method return tue if file opened and false	 if file created so applictaion knows what is occuring  	 	 	 	 oops i think this is bit clumsy should have jusust had a bool (default = false) and set true	 what the hell was i thinking?	-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000118 RETURN AN INDICATION ON WETHER A FILE OPENED OR CREATED	Will make openORCreate return a bool where		return = true file was opened		return = false file was created and opened	This will require changes to openOrCreateConnection; FinishOpenOrCreateConnection -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-PROTECTION AGAINST CTREATING MISSING FILES IN OPEN OR CREATE000119FinishOpenOrCreateConnection can open several files these being		optional super file		each table file		special file	as was mentioned earlier if a table file is missing (in a non superFile) but the other exist	we could have a problem as we would end up with a set of mostly populated tables and one empty table	this could be disatress (espicially if the realtionships are involved)	should a client be allowd to create missing tables or is this admin function?		possibe answers		1. have optional code that can be used to detect this situation and assert or exception	2. ignore it 	3. rather than a bool use an enum {opened,created, missing tables)			i like three as it alllows the user to decide	Number two could be dangerous	As for one mmm i say		Final solution  internally track file state, if bad throw an exception		To detct missing table we wouldneed a state machine of some sort	read the following as [initial state][transition]->[next state]		start 			Open	->	File Opened		start			Create	->  File Created		File Opened		Open	->  File Opened		File Opened		Create	->  Files Bad		File Created	Open	->  Files Bad		File Created	Create	->  File Created		Files Bad		Create	->  Files Bad		Files Bad		Open	->  Files BadAssumption if a super file is opened it either has all files or no files sp return state will just depend onthe datafileswe do not have to worry aboyt super file, if we open a super file the file state depends on we must have an idel state = 0 and start state = 1and the oth states = 2 4 8, this allows us to or the results we need a non zro state for start or else start| open = open and this ambigious if we encode the transition implictly by going fronm one state to the other teci made the enum state a private member of oofctree connection but a more logical state to do this is in oofctree Backend as else oofctreeconnection & dbTable must also no what the state is, no this will not work as the backend is  on a table basis, but the state is tracked acorss multiple tables,put statemachine in to dbConnect ctree and pass state back through backend, then table. this is a painas we must make the enum type public in connect and let table and backend know about itbut still must expose setStartState at tablelevel, 	thought about this but this is a bit clumsy, assumingthat connection  can only open tables during connection time (checked code and this appears so)set the initial state during construction of oofctree backend. -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-PROTECTION AGAINST CREATING MISSING FILES IN OPEN OR CREATE000121must move state enum from ctree_connect to db_Connect so that table openconnection method return type is not dpendent on ctree filesNo i don't the state will be maintained in dbconnect_ctree this weiil be privateTable will just return open or create (true false) so state will be mantianed internally in dbConnect ctreeInternally still kkep the state enum connectionFileStateT as it allows us to have a nice initial state PROTECTION AGAINST CREATING MISSING FILES IN OPEN OR CREATE000122rather than the all ecompassing eBadFile, add eOpenInCreation & eCreationInOpen, also throw ecception in dbConnect_finnshopenorcreateConnection if these states occurcreateOrOpen (openOrCreate?) is an ambigiuos name use createIfMissing instead-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-TRANSACTION PROCESSING000124  the miminmilist transaction processing is desribed in 3.2 pg 1113 of faircomm installation guide v6.8. It states that LOCKISAM(enable) calls can be replaced with begin(trnlog|enable) calls and that LOCKISAM(free) can be replaced with commit (free calls)now these idsam call are currentlty wrapped into oofile calls virtual void exitLocking();	virtual void enterWriteLocking();	COUNT err = ::LockISAM(ENABLE);virtual void enterReadLocking();COUNT err = ::LockISAM(READREC);COUNT err = ::LockISAM(ENABLE);	::LockISAM(FREE);it apeears that oofile currently has no automatic locking it must be done manually, wrong in enterwrite lockingENABLE is set, this means that any read wil attempt to get a write lock on the that record this means thatthat record will be blocked from othes using it. So the user sets awrite lock and all reeads till a ::LockISAM(FREE) is invoked. so  all we need is a transaction version of the above calls  to get minimal transactions  read using above aclls so to avhieve minimum functionality we need versions of the above calls with begin and and end calls insideQUESTION ONE 	should we create a begin transaction method or just make a variant of the abobve methods maybe with an optional paramter	the advantage of using a the existing methods is that existing code can be easly adapted, 	the disacvantage is that the function would be ambigious there is no indication  in t the name	enterWriteLocking of the fact that it is a tranascation method	proposed solution make  beginTransaction endTransaction methods, add a conditional cal to the 	start/end trnasaction calls in the enter locking calls. No this is no good as user will still have to go through and modify all enterlocking calls, better to use begin transaction model and do a search and replace on enterlocking callswe also will need fancy buffering to handle transactions more on this being the -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-TRANSACTION PROCESSING000125  checking in kidmap and discusiion with cam i found that a much cleaner and nicer locking system existsin oofile stLockRecord object this object locks record on instantiation and when stack goes out of scope, the destructor removes lock.these operate as follows stLockRecord	InitLock		mTable->lockRecord			mBackend->lockRecord (backend is ctree)~stLockRecord	mTable->unlockRecord();			unlockRecord (backend is ctree)							to continue in this pattern we will make an stTransactRecord to enable transactionand add an optional paramter on lock and unlock record to iether ctree lock call or beginand the matching unlock(free) or commit 			checked with andy boththese methos are used, so will have to handle boththe enter locking calls are mainly used by the gui  and edit helper so chase theseall the clever locking is actualy done by oofguinow these locks will ultimayly debomve transaction pointsgui nicley handles locking as followsif when we change the current record(selection? i think we have some bad naming here)it locks the record when the following method are invokedgoFirstRecordgoLastRecordgoNextRecordgoPreviousRecordthese callchangedSelection					METHOD changesSekection	    rtey and lock the record	    bool someoneElseLocked = false;		IF someoneElseLocked THEN			broadcast OOFmsg_ChangeSelection, kRecordLockedByOtherUser		ELSE			broadcast OOFmsg_ChangeSelection, 0		END_IF			these message go to dbAbstractEditHelper::receiveMsg and set readonly flag on the record and all asscotaied linksthis will not 	try {		mTable->lockRecord();	}	catch (oofE_RecordLocked&) {		oofYNC("Someone else is editing this record - you will not be able to make any changes");		someoneElseLocked = true;	}	if (someoneElseLocked) 		(OOFmsg_ChangeSelection, kRecordLockedByOtherUser, dontNeedToTell);	else 		broadcast(OOFmsg_ChangeSelection, 0, dontNeedToTell); END_METHODby goto,leave, ==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-TRANSACTION PROCESSING000126  these methods bypass the GUI automatic locking and are used so conveert them to transaction firts exitLocking()enterWriteLocking()enterReadLocking()we need a way to choose between multi user and clent servercould use #ifdef TRANSPROCbut this would block out mixed LOCLIB buildspherhaps#ifdef TRANSPROC	if(is client connection){		client stuff		}else#endif	{		exisiting		mulituser stuff	}yes, but iehetr have a flag isCleintconnection or store pointer to dbUser optional logoninfobut these functions currently use #ifndef NOTFORCE, for multi userwe need 	if not multi user then		use exisint code	else		if tranprocr then			client stuff		else			existing code (but if trans proc ie client then notforce so we do need two copies of code			)		end_if			end_if	no netter would be the rather hoorible ?no not compile time but run timeIF notforceif not multi user then		use exisint code	else		if tranprocr then			client stuff		else			existing code (but if trans proc ie client then notforce so we do need two copies of code			)		end_if			end_if	IF NOT DEFINED notforce THEN ( it's a multiUser non server)	existing codeELSE (#else) 	IF DEFINED TRANSPROC THEN (it's a client server but connection may be local client)		IF clientConnection THEN			Begin transaction code		ELSE			no code as a local is a single user (but we must cover a single user compile i suppose)		END_IF	ELSE		no code we aresinsingle world but i do not think this is aa valid oofile state		but existing code would compile to an empty call 		END_IF  (#endif)   	END_IF (#endif) 	Repeat pattern for write locking and write exitCOUNT err = ::LockISAM(ENABLE);	::LockISAM(FREE);		13/03/00 no a local in oofile is stil a mutli user but can we have a						edit helper 								-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-TRANSACTION PROCESSING  in oofile a ctree connection is always a mutliuser  FPUTFGET  	MULTIUSER-NONSERVER is definedfputget is mutually exclusive to NOTFORCE  we include ctoPtion.h in oofile ctree buils in which thee valuse are definedand these only affect locking methods, instead of using notforce we could use transproc.decsion in a client server application expilcit locking will be disallowed on a locLib, ie no muliuser loclibs will be allowed as that is a function of the server -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-IMPORTANT NOTE000317 it appears that if A SERVER FILE IS PRESENT 	and has the same name   name as a standalone filethe library will open the server file and not create it's own file this was with the server off-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-TRANSACTION PROCESSING000317in the gui -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000329	  FIX BUG THAT CAUSES LOSS OF SYNCH BETWEEN GUI AND DATABASE	Test in sample contacts found that the gui lost synch with the data base, this was traced to the assumption made that begin() function returns an error code. It actually returns a transcation number and zero for error, to find what errorhas occured call uerr_cod or in oofile mConnection->uerr_codOOF_ctreeBackend::beginTransaction()		- changed variable err to res		  changed if(err) to if(!res)		  replaced err paramter in excp() call with a call to mConnection->uerr_cod		  -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000329		  TRANSACTION PROCESSING fputfget notforce ctboundwe will need to know if the connection is we are is a 	a) local single user lib in a clientserver lodel(we never actually test this mode)version 2 assert	b) multiuser nonserver	c) multi user client serverwe cannort depend on just conditional compilies as a user may have a local standalone ctree libnow a) is defined by#defined TRANSPROCb) is defined by		- #ifndef NOTFORCE	no we wont the loc lib and client will be compilied into one libary, each ctree will have it's own isntance and we will expilcitly switch between them so we will always no which one we haveas for transactio porcesinng the loc lib must be compiled with ytransproc defined, so we can assume that calling a transction function on loc instance well not mewtter so we will just have ifdef transproc	stuff endifand c) is defined by 	checked faircom documents to build a dual client local lib, it appears that we must do the following(ref to ProgrammerÕs Reference Guide Chapter - 2 pg 271. build a local lib with ctLOCLIB defined and name the lib ctllib.lib -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000329		  TRANSACTION PROCESSING in GENERATE TEST DATAIn the dbTable::generateTestDat will add beginTransaction call just before saveRecord() call imeddialtlY afterwe will commitRecord(). both of these calls will be optionallyt compiled if TRANSPROC is defined. We begin trnasaction until the save as oofile doesnot hit ctree until the save occurs on new records-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000404		  UPDATE BUGWHEN testing contacts with ooftest66 locking record eight, when we move from eight to five all the fields where not updated, in fact only the notes field was updated.Quit ooftest 66 still got errorRestarted contacts and got no bug, it appears that the collision with the record locked by ooftest 66 nocks the syste out og synchthis test involved running ooftest66 choosing option one and locking first record then launching contactsnote in this test mTransaction state did not change apart frpm the initial connect and the final destruction, this because thedbgui only obtains a lock on the currently highligted record test two as above but lock second recordwalhtrough and document of state change could find no error. tested a non debug version and it worked it appeared thatthis is a side effect of pane update in debyug mode with lots of windows coming and going so treat as ok.-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000404		  COMMITTING EDITED RECORDScurrently if the user edits a field the table is set to dirty (actually in the backend), if the user then leaves a field in the gui then the gui prompts thenm to save itIf the user chooses save then then the record is saved and the transaction is committed, however if the user saves the record without leaving a record then the mDirty flag is clearedand when the user leaves the record the transaction will be be aborted as the record is not dirty. it makes sens that the user could make several saves aasthey edit a large record.Decsion	- add an mDirtiedTransaction member to the dbGui which will be set on an expilcit call to save record and cleared after a record is commited	when leaving a record in the gui	wiif dirty or tranasction dirty commit else abortorigonally i was going to put the mDirtiedTransaction into gui, but it would be better to put into dbtable, there are two reasons for this	1. It will be avialable to noGui users	2. it need to cleared when dbTable commit or abort record is called, so it is more logical to put it inoto table		State Rules for mDirtiedTransaction 		a. init to false		b. IF in transaction and save THEN set to true		b. IF in Transaction and commit ot abort then set to falseQuestions1. what about beginTransactions ? 	-I think they should set  mDirtiedTransaction to false.2. dbTable has the mCurrent record locked state variable, so it makes sense that the mInTransaction state is held here as they effictvly are the same class of action.  In fact faircom state that the simpilist conversion path is to convert lock isam call to begin calls  3. what about cloned tables who get transaction stuff dtbtable clone constructer hasmLockedCurrentRecord(false),	// clone does NOT manage locking unless shared sel ** llok into this**	-currently it appears that locks are invoked at the gui level. 		If a table is cloned the user must make sure that no locks/transactions are invoked/released on the clone, 	this means that autolocking is dissallowed. 4. where shoukd mTransactionDirty go?-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000407	  BAD PASSWORDSctree InitISAMXtd can return the following erros when connecting to a client450 LUID_ERR Invalid user ID.451 LPWD_ERR Invalid user password.453 NSRV_ERR Invalid Server name.we need some way of handling this, perhaps we should invoke an error onuser with a tree time countwhat we need on user is a logOnerror Method which is passed the res of the InitISAMXtd callit will haddle errors LUID_ERR LPWD_ERR NSRV_ERR else it pass them back WHILE res = InitISAMXtd != 0 OR notThreeTries DO	not threeTries = dbUserlogOnRrror(res)END_WHILE These errors are clearly oofE_CtreeConnectionError but they are lokely to be common, due to log on typo's etc, rather than add functionlity to oofE_CtreeConnectionError will add a child method oofE_CtreeConnectionLogOnError, this will include a method to get the error type, we will exapnd upon the avove list 	LUID_ERR Invalid user ID.		to long		to short  		to long		to short 		to long		to short alraedy does this is oofE_CtreeConnectionError so all we need is the oofE_CtreeConnectionErrorill allow getting of our own internal eror numberSo Decsion add ode to detect the three erros  () in SetupConnection to generate special exceptions messages for ech of these  and or an error string return but what about the erros of the password or id is to long?is two long page spinner-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000410	  BAD PASSWORDSctree InitISAMXtd can return the following erros when connecting to a client450 LUID_ERR Invalid user ID.451 LPWD_ERR Invalid user password.453 NSRV_ERR Invalid Server name.things to add 1	.user profiles dbuser + testcase for dbuser2.  better error handling to dbuser	maybe if word to long throw exception	DECSION 	add an oofE_dbUser object to handle attempts  to set overlength passwords in dbUser	add code to handle: LUID_ERR; LPWD_ERR and NSRV_ERR through exceptions in dbConnect_ctree::SetupConnection	should user-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000412	  SETTING TRANSACTION MODESwe need a method to set up the transaction mode, we could handle this by attaching the mode to dbUserbut dbUser's responisbilty is to handle user logon details and server name and loc.Instead the the mode should be passed in as a paramter to dbconnect with a default value of TRNLOG. this assumes that generally the user will want transaction processing Will add an invariant function to dbConnect_ctree to guard against invalid combinations of file modes. Instead of invariant call it validateFileMode.-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000413	  SETTING INDICIES ON SHARED FILESfaircom ctfuncrf.pdf states"To call PermIIndex, you must have the underlying Incremental files opened exclu-sively."so will add an assert in OOF_ctreeBackend::addIndices to protect against thiswe need an abstarction for wher the file to open is, i think a special instance of oofdir might be the think to use, experiment can we put the file anywhere-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000414  SETTING TRANSACTION MODESInitial thought was to pass the transaction mode down to the backend, when the files were opened or created, however the tranasction modes are ulimatly passed into the open file routines throught the filmod parameter of the IFIL structure. OOFile currenlty passes in the file modes throught the statics	OOF_ctreeBackend::sFileMode	dbConnect_ctree::sFileMode  which are effectivly defined globally in oofctre4.cpp. in order to pass the transaction modes down, would involve a lot of code changes. So it would be best to use the existing statics.The current sFileMode settings set up ctree for multiuser or client  or single user and within a given oofile context this is constant.However a user could concievably want to have different conections with differnt tranasction modes, so have decided to set transaction mode through paramter onin dbConnect_ctree methods: 		openConnection			openOrCreateConnection		-added mTransactionMode setting-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	000414  GUARDING AGAINST INVALID FILE MODES It would be better to check the filemode validity in oof_ctreeBackend buildifil method rather than just tranasction validity in dbConnect_ctreeas we could then guard against invalid file modes as well as invalid tranasction modes, although sFileMode is static and we could check it in the dbConnectthe buildIFIL is lower down the call chain and would catch inadverdant changes to sFileMode.So move validTransactionmode to oof_ctreeBackend and rename to validFileMode. 	-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	000414  DEFAULT TRANSACTION MODE Initailly chose trnlog. but this is bad default should be no transaction, as that is the way oofile origonally was. Dfeault should be SAME OLD OOFILE (no surprises)-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000417  SETTING TRANSACTION MODES DETECTION OF BAD MODESEach of the following pairs state is held in a single bit so they are mutually exclusive.	VIRTUAL, PERMANENT	ctFIXED, VLENGTHFor example if the user sets long fileMode = (VIRTUAL| PERMANENT) the state will be PERMANENT			if the user sets long fileMode = (ctFIXED|VLENGTH) the state will be VLENGTHinitial thought that user could set both and guarded against these with code like:	if( ( (VIRTUAL| PERMANENT)&fileMode) == (VIRTUAL| PERMANENT) ) 		res = false;However we cannot protect hte user against these combinations. The onus is on user they must be careful. PREIMG is the same as file mode SHADOW TRNLOG is the a combination of SHADOW & LOGFIL (ie (LOGFIL | SHADOW) as a result we cannot protect against PREIMG and TRNLOG (faircomm  manual states that user must choose one of them)   -=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000417  CLIENT FAILURETesting has shown that if a client fails without committing the changes are lost even if saveRecord was invoked SETTING TRANSACTION MODES DETECTION OF BAD MODES-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000501FACTORING CLIENT CODEdbConnect_ctree & dbConnect_ctreeClient will both have the same code to build schema so factor this code out into dbConnect_ctree::BuildConnectionSchemas-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-000505FACTORING CLIENT CODEIn dbTable will take any beging transaction out of #ifdef TRANSPROC ( a ct def) to make it possible for other future backends to have transactions, instead make the trnasction procduresinto empty functions, and have the actual transaction code in the  OOF_ctreeClientBackend  dbConnect_ctreeClient will use dbConnect_ctree's methods  	FinishNewConnection	FinishOpenConnection	FinishOpenOrCreateConnectionso change these from private to protecteddbConnect_ctreeClient will use dbConnect_ctree's membersso change these to protected	//COUNT mBlobFilNo, mISAMdatno;  // c-tree file number handling  // david factoring 000503OOF_ctreeClientBackend will use OOF_ctreeBackend members 	mConnection	mBlobFilNo	mISAMdatnoso change from private to protected dbuser has a an oofE_dbUser excpetion object facptor this code out of the general excpetion files oofexcep.h & eoofexep.cpp and place into dbUser.h & ctreserver.cpp xxxxxxxx  ctreserver.cpp is a dumb name change to oofctcnt.cpp (oofctreeclient)   to make resolution of include files easier moved oofdbuser def to own file